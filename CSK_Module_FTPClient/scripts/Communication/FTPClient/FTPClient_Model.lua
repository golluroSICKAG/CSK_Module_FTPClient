---@diagnostic disable: undefined-global, redundant-parameter, missing-parameter
--*****************************************************************
-- Inside of this script, you will find the FTPClient_Model definition
-- including its parameters and functions
--*****************************************************************

--**************************************************************************
--**********************Start Global Scope *********************************
--**************************************************************************
local nameOfModule = 'CSK_FTPClient'

local ftpClient_Model = {}

-- Check if CSK_UserManagement module can be used
ftpClient_Model.userManagementModuleAvailable = CSK_UserManagement ~= nil or false

-- Check if CSK_PersistentData module can be used if wanted
ftpClient_Model.persistentModuleAvailable = CSK_PersistentData ~= nil or false

-- Default values for persistent data
-- If available, following values will be updated from data of CSK_PersistentData module (check CSK_PersistentData module for this)
ftpClient_Model.parametersName = 'CSK_FTPClient_Parameter' -- name of parameter dataset to be used for this module
ftpClient_Model.parameterLoadOnReboot = false -- Status if parameter dataset should be loaded on app/device reboot

-- Load script to communicate with the FTPClient_Model interface and give access
-- to the FTPClient_Model object.
-- Check / edit this script to see/edit functions which communicate with the UI
local setFTPClient_Model_Handle = require('Communication/FTPClient/FTPClient_Controller')
setFTPClient_Model_Handle(ftpClient_Model)

ftpClient_Model.helperFuncs = require('Communication/FTPClient/helper/funcs')

-- Create a FTP client instance
if _G.availableAPIs.specific == true then
  ftpClient_Model.ftpClient = FTPClient.create() -- FTP client to use for FTP connection
  if _G.availableAPIs.imageSpecific == true then
    ftpClient_Model.formatter = Image.Format.JPEG.create() -- Formatter instance (JPG per default)
  end

  -- Function to be processed asynchronously if 'asyncMode' is used
  ftpClient_Model.async = Engine.AsyncFunction.create()
  ftpClient_Model.async:setFunction("FTPClient.put", ftpClient_Model.ftpClient)
end
ftpClient_Model.counter = 1 -- Internal counter, e.g. used to count sent data and use it for naming

ftpClient_Model.eventSelection = '' -- Event selection in UI table
ftpClient_Model.registeredEventName = 'CSK_Module.EventName' -- Preset event name to register for incoming data
ftpClient_Model.dataType = 'DATA' -- Preset type of incoming data of event to save on FTP server
ftpClient_Model.autoFilename = false -- Preset status if filename should be generated by timestamp
ftpClient_Model.sourceFilePath = '/public/Data.file' -- Source to local file to send to FTP server

ftpClient_Model.styleForUI = 'None' -- Optional parameter to set UI style
ftpClient_Model.version = Engine.getCurrentAppVersion() -- Version of module

-- Parameters to be saved permanently if wanted
ftpClient_Model.parameters = {}
ftpClient_Model.parameters = ftpClient_Model.helperFuncs.defaultParameters.getParameters() -- Load default parameters

--**************************************************************************
--********************** End Global Scope **********************************
--**************************************************************************
--**********************Start Function Scope *******************************
--**************************************************************************

--- Function to react on UI style change
local function handleOnStyleChanged(theme)
  ftpClient_Model.styleForUI = theme
  Script.notifyEvent("FTPClient_OnNewStatusCSKStyle", ftpClient_Model.styleForUI)
end
Script.register('CSK_PersistentData.OnNewStatusCSKStyle', handleOnStyleChanged)

--- Checking of the asynchronous FTP transfer process
---@param futureHandle Engine.AsyncFunction.Future The future object identifying the function call
local function checkDataTransfer(futureHandle)

  local suc = futureHandle:isFailed()
  if suc then
    _G.logger:warning(nameOfModule .. ": FTP put error.")
    Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", false)
  else
    _G.logger:fine(nameOfModule .. ": FTP put OK.")
    Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", true)
  end
end

local function setupFTPClient()
  Script.releaseObject(ftpClient_Model.async)
  Script.releaseObject(ftpClient_Model.ftpClient)
  collectgarbage()

  ftpClient_Model.ftpClient = FTPClient.create() -- FTP client to use for FTP connection

  -- Function to be processed asynchronously if 'asyncMode' is used
  ftpClient_Model.async = Engine.AsyncFunction.create()
  ftpClient_Model.async:setFunction("FTPClient.put", ftpClient_Model.ftpClient)

  Engine.AsyncFunction.register(ftpClient_Model.async, "OnFinished", checkDataTransfer)

  ftpClient_Model.ftpClient = FTPClient.create() -- Recreate FTP client
  ftpClient_Model.async:setFunction("FTPClient.put", ftpClient_Model.ftpClient)
  ftpClient_Model.ftpClient:setIpAddress(ftpClient_Model.parameters.serverIP)
  ftpClient_Model.ftpClient:setPort(ftpClient_Model.parameters.port)
  ftpClient_Model.ftpClient:setPassiveMode(ftpClient_Model.parameters.passiveMode)
  ftpClient_Model.ftpClient:setVerbose(ftpClient_Model.parameters.verboseMode)

  if ftpClient_Model.parameters.mode == 'SFTP' then
    ftpClient_Model.ftpClient:setSecurityProtocol('SFTP')
    if ftpClient_Model.parameters.privateKeyPathSFTP ~= '' then
      if File.exists(ftpClient_Model.parameters.privateKeyPasswordSFTP) then
        if ftpClient_Model.parameters.privateKeyPasswordSFTP ~= '' then
          if ftpClient_Model.parameters.publicKeyFilePathSFTP ~= '' then
            if File.exists(ftpClient_Model.parameters.publicKeyFilePathSFTP) then
              ftpClient_Model.ftpClient:setSSHKeyFile(ftpClient_Model.parameters.privateKeyPathSFTP, ftpClient_Model.parameters.privateKeyPasswordSFTP, ftpClient_Model.parameters.publicKeyFilePathSFTP)
            else
              _G.logger:warning(nameOfModule .. ": Public key file does not exist.")
            end
          else
            ftpClient_Model.ftpClient:setSSHKeyFile(ftpClient_Model.parameters.privateKeyPathSFTP, ftpClient_Model.parameters.privateKeyPasswordSFTP)
          end
        else
          if ftpClient_Model.parameters.publicKeyFilePathSFTP ~= '' then
            if File.exists(ftpClient_Model.parameters.publicKeyFilePathSFTP) then
              ftpClient_Model.ftpClient:setSSHKeyFile(ftpClient_Model.parameters.privateKeyPathSFTP, nil, ftpClient_Model.parameters.publicKeyFilePathSFTP)
            else
              _G.logger:warning(nameOfModule .. ": Public key file does not exist.")
            end
          else
            ftpClient_Model.ftpClient:setSSHKeyFile(ftpClient_Model.parameters.privateKeyPathSFTP)
          end
        end
      else
        _G.logger:warning(nameOfModule .. ": Private key file does not exist.")
      end
    end

    if ftpClient_Model.parameters.knownHostFilePathSFTP ~= '' then
      if File.exists(ftpClient_Model.parameters.knownHostFilePathSFTP) then
        ftpClient_Model.ftpClient:setSSHKnownHostsFile(ftpClient_Model.parameters.knownHostFilePathSFTP)
      else
        _G.logger:warning(nameOfModule .. ": Known host file does not exist.")
      end
    end

  elseif ftpClient_Model.parameters.mode == 'FTPS' then
    ftpClient_Model.ftpClient:setSecurityProtocol(ftpClient_Model.parameters.securityProtocolFTPS)
    if ftpClient_Model.parameters.caBundlePath ~= '' then
      if File.exists(ftpClient_Model.parameters.caBundlePath) then
        ftpClient_Model.ftpClient:setCABundle(ftpClient_Model.parameters.caBundlePath)
      else
        _G.logger:warning(nameOfModule .. ": CA Bundle file does not exist.")
      end
    end
    if ftpClient_Model.parameters.peerVerification then
      ftpClient_Model.ftpClient:setPeerVerification(true)
    else
      ftpClient_Model.ftpClient:setPeerVerification(false)
    end
  else
    ftpClient_Model.ftpClient:setSecurityProtocol('NONE')
  end
end
ftpClient_Model.setupFTPClient = setupFTPClient

local function putFile(localSource, destination)
  if ftpClient_Model.ftpClient:isConnected() then
    if File.exists(localSource) then
      local putSuccess = false
      if destination then
        putSuccess = ftpClient_Model.ftpClient:putFile(destination, localSource)
      else
        local foundPos = nil
        for pos in localSource:gmatch("()" .. '/') do
          foundPos = pos
        end
        if foundPos then
          local fileName = string.sub(localSource, foundPos+1)
          putSuccess = ftpClient_Model.ftpClient:putFile(fileName, localSource)
        else
          _G.logger:info(nameOfModule .. ": No file transfer. Please check local source = " .. tostring(localSource))
        end
      end
      _G.logger:info(nameOfModule .. ": File transfer success = " .. tostring(putSuccess))
      Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", putSuccess, localSource)
      return putSuccess
    else
      _G.logger:warning(nameOfModule .. ": File does not exist: " .. tostring(localSource))
      Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", false, localSource)
      return false
    end
  else
    _G.logger:info(nameOfModule .. ": FTP server not connected.")
    Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", false, localSource)
    return false
  end
end
Script.serveFunction('CSK_FTPClient.putFile', putFile)
ftpClient_Model.putFile = putFile

local function sendData(data, filename)
  if ftpClient_Model.ftpClient:isConnected() then
    _G.logger:fine(nameOfModule .. ": Try to send data")

    if ftpClient_Model.parameters.asyncMode then --> Asynchronous image transfer
      ftpClient_Model.async:launch(filename, data)
      return true

    else --> Non asynchronous image transfer
      local suc = ftpClient_Model.ftpClient:put(filename, data)

      if suc then
        _G.logger:fine(nameOfModule .. ": FTP put OK.")
        Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", true, filename)
        return true
      else
        _G.logger:warning(nameOfModule .. ": FTP put error.")
        Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", false, filename)
        return false
      end
    end

  else
    _G.logger:warning(nameOfModule .. ": No FTP connection.")
    Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", false, filename)
    return false
  end
  return false  
end
Script.serveFunction("CSK_FTPClient.sendData", sendData)
ftpClient_Model.sendData = sendData

--- Function to add date/time info to data to send to FTP server
---@param data auto Data to send to FTP server
local function addDataFilename(data)
  local day, month, year, hour, minute, second = DateTime.getDateTimeValuesLocal()
  local customDate = year .. string.format("%02d%02d", month, day)
  local customTime = string.format("%02d%02d%02d", hour, minute, second)
  sendData(data, customDate .. '_' .. customTime .. '.dat')
end

--- Function to add date/time info to binary iamge data to send to FTP server
---@param data auto Data to send to FTP server
local function addDataFilenameToRawImage(data)
  local day, month, year, hour, minute, second = DateTime.getDateTimeValuesLocal()
  local customDate = year .. string.format("%02d%02d", month, day)
  local customTime = string.format("%02d%02d%02d", hour, minute, second)
  sendData(data, customDate .. '_' .. customTime .. '.jpg')
end

local function sendImage(img, filename)
  if ftpClient_Model.ftpClient:isConnected() then
    _G.logger:fine(nameOfModule .. ": Try to send image")
    if _G.availableAPIs.imageSpecific then
      local compImg = ftpClient_Model.formatter:encode(img)

      if ftpClient_Model.parameters.asyncMode then --> Asynchronous image transfer
        if filename then
          ftpClient_Model.async:launch(filename .. '.jpg', compImg)
        elseif ftpClient_Model.parameters.imageName == "unknown" then
          ftpClient_Model.async:launch(ftpClient_Model.parameters.imageName .. 'image' .. tostring(ftpClient_Model.counter) .. '.jpg', compImg)
          ftpClient_Model.counter = ftpClient_Model.counter + 1
        else
          ftpClient_Model.async:launch(ftpClient_Model.parameters.imageName .. '.jpg', compImg)
        end
        return true

      else --> Non asynchronous image transfer
        local suc = false
        if filename then
          suc = ftpClient_Model.ftpClient:put(filename .. '.jpg', compImg)
        elseif ftpClient_Model.parameters.imageName == "unknown" then
          filename = ftpClient_Model.parameters.imageName .. 'image' .. tostring(ftpClient_Model.counter)
          suc = ftpClient_Model.ftpClient:put(filename .. '.jpg', compImg)
          if suc then
            ftpClient_Model.counter = ftpClient_Model.counter + 1
          end
        else
          filename = ftpClient_Model.parameters.imageName
          suc = ftpClient_Model.ftpClient:put(ftpClient_Model.parameters.imageName .. '.jpg', compImg)
        end
        if suc then
          _G.logger:fine(nameOfModule .. ": FTP put OK.")
          Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", true, filename)
          return true
        else
          _G.logger:warning(nameOfModule .. ": FTP put error.")
          Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", false, filename)
          return false
        end
      end
    else
      _G.logger:warning(nameOfModule .. ": No image processing available...")
      Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", false, '')
      return false
    end

  else
    _G.logger:warning(nameOfModule .. ": No FTP connection.")
    Script.notifyEvent("FTPClient_OnNewStatusFileTransferSuccess", false, filename or '')
    return false
  end
end
Script.serveFunction("CSK_FTPClient.sendImage", sendImage)
ftpClient_Model.sendImage = sendImage

--- Function to add date/time info to iamge to send to FTP server
---@param data auto Image to send to FTP server
local function addImageFilename(data)
  local day, month, year, hour, minute, second = DateTime.getDateTimeValuesLocal()
  local customDate = year .. string.format("%02d%02d", month, day)
  local customTime = string.format("%02d%02d%02d", hour, minute, second)
  sendImage(data, customDate .. '_' .. customTime)
end

--- Function to register to event to receive data to send to FTP server
---@param eventName string Name of event
---@param dataType string Type of data
---@param autoFilename bool Status if filename should be created by date/time info
local function registerEvent(eventName, dataType, autoFilename)
  if dataType == 'DATA' then
    if autoFilename then
      Script.register(eventName, addDataFilename)
    else
      Script.register(eventName, sendData)
    end
  elseif dataType == 'JPG' then
    if autoFilename then
      Script.register(eventName, addImageFilename)
    else
      Script.register(eventName, sendImage)
    end
  elseif dataType == 'RAW_JPG' then
    if autoFilename then
      Script.register(eventName, addDataFilenameToRawImage)
    else
      Script.register(eventName, sendData)
    end
  end
end
ftpClient_Model.registerEvent = registerEvent

--- Function to deregister from event to send data/image to FTP server
---@param eventName string Name of event
---@param dataType string Type of data
---@param autoFilename bool Status if filename should be created by date/time info
local function deregisterEvent(eventName, dataType, autoFilename)
  if dataType == 'DATA' then
    if autoFilename then
      Script.deregister(eventName, addDataFilename)
    else
      Script.deregister(eventName, sendData)
    end
  elseif dataType == 'JPG' then
    if autoFilename then
      Script.deregister(eventName, addImageFilename)
    else
      Script.deregister(eventName, sendImage)
    end
  elseif dataType == 'RAW_JPG' then
    if autoFilename then
      Script.deregister(eventName, addDataFilenameToRawImage)
    else
      Script.deregister(eventName, sendData)
    end
  end
end
ftpClient_Model.deregisterEvent = deregisterEvent

--- Function to register to all events
local function registerAllEvents()
  for key, _ in pairs(ftpClient_Model.parameters.registeredEvents) do
    registerEvent(key, ftpClient_Model.parameters.registeredEvents[key].dataType, ftpClient_Model.parameters.registeredEvents[key].autoFilename)
  end
end
ftpClient_Model.registerAllEvents = registerAllEvents

--- Function to deregister from all events
local function deregisterAllEvents()
  for key, _ in pairs(ftpClient_Model.parameters.registeredEvents) do
    deregisterEvent(key, ftpClient_Model.parameters.registeredEvents[key].dataType, ftpClient_Model.parameters.registeredEvents[key].autoFilename)
  end
end
ftpClient_Model.deregisterAllEvents = deregisterAllEvents

return ftpClient_Model